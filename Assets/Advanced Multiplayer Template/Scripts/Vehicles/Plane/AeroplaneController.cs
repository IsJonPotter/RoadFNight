using Mirror;
using StarterAssets;
using System;
using System.Collections;
using UnityEngine;
using VehicleEnterExit;

namespace UnityStandardAssets.Vehicles.Aeroplane
{
    [RequireComponent(typeof (Rigidbody))]
    public class AeroplaneController : NetworkBehaviour
    {
        [SerializeField] private float m_MaxEnginePower = 40f;        // The maximum output of the engine.
        [SerializeField] private float m_Lift = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
        [SerializeField] private float m_ZeroLiftSpeed = 300;         // The speed at which lift is no longer applied.
        [SerializeField] private float m_RollEffect = 1f;             // The strength of effect for roll input.
        [SerializeField] private float m_PitchEffect = 1f;            // The strength of effect for pitch input.
        [SerializeField] private float m_YawEffect = 0.2f;            // The strength of effect for yaw input.
        [SerializeField] private float m_BankedTurnEffect = 0.5f;     // The amount of turn from doing a banked turn.
        [SerializeField] private float m_AerodynamicEffect = 0.02f;   // How much aerodynamics affect the speed of the aeroplane.
        [SerializeField] private float m_AutoTurnPitch = 0.5f;        // How much the aeroplane automatically pitches when in a banked turn.
        [SerializeField] private float m_AutoRollLevel = 0.2f;        // How much the aeroplane tries to level when not rolling.
        [SerializeField] private float m_AutoPitchLevel = 0.2f;       // How much the aeroplane tries to level when not pitching.
        [SerializeField] private float m_AirBrakesEffect = 3f;        // How much the air brakes effect the drag.
        [SerializeField] private float m_ThrottleChangeSpeed = 0.3f;  // The speed with which the throttle changes.
        [SerializeField] private float m_DragIncreaseFactor = 0.001f; // how much drag should increase with speed.

        public float Altitude { get; set; }                     // The aeroplane's height above the ground.
        public float Throttle { get; set; }                     // The amount of throttle being used.
        public bool AirBrakes { get; set; }                     // Whether or not the air brakes are being applied.
        public float ForwardSpeed { get; set; }                 // How fast the aeroplane is traveling in it's forward direction.
        public float EnginePower { get; set; }                  // How much power the engine is being given.
        public float MaxEnginePower{ get { return m_MaxEnginePower; }}    // The maximum output of the engine.
        public float RollAngle { get; set; }
        public float PitchAngle { get; set; }
        public float RollInput { get; set; }
        public float PitchInput { get; set; }
        public float YawInput { get; set; }
        public float ThrottleInput { get; set; }
        [HideInInspector] public StarterAssetsInputs _input;

        private float m_OriginalDrag;         // The drag when the scene starts.
        private float m_OriginalAngularDrag;  // The angular drag when the scene starts.
        private float m_AeroFactor;
        private bool m_Immobilized = false;   // used for making the plane uncontrollable, i.e. if it has been hit or crashed.
        private float m_BankedTurnAmount;
        private Rigidbody m_Rigidbody;
	    WheelCollider[] m_WheelColliders;


        public GameObject VehicleUI;
        [Header("Rocket Launchers")]
        public bool canPlaneShoot = true;
        public GameObject rocketPrefab;
        public float rocketSpeed;
        public Transform rocketInitialPositionLeft;
        public GameObject rocketObjectLeft;
        public Transform rocketInitialPositionRight;
        public GameObject rocketObjectRight;
        public string currentRocketInitialPosition = "Left";
        public float rocketsDelay = 0.5f;
        public bool hasDelay = false;
        public Transform rocketsTarget;
        bool canShootRocket = true;
        int shotRockets = 0;
        int availableRockets = 2;
        public TMPro.TMP_Text shotRocketsText;
        bool rocketShot = false;
        bool rocketsSelected = false;
        public GameObject rocketsSelectedUI;
        [Header("Minigun")]
        public GameObject bulletPrefab;
        public Transform bulletInitialPositionLeft;
        public Transform bulletInitialPositionRight;
        public float bulletSpeed;
        int bulletsShot = 0;
        public int ShotsUntilOverheating = 30;
        public float OverheatingCoolDown = 5;
        bool isOverheating = false;
        public GameObject overheatingUI;
        public GameObject minigunsSelectedUI;
        public AudioClip minigunSound;
        public AudioClip overheatingSound;
        public AudioSource minigunAudioSource;
        [Header("Minigun Caliber 30 mm")]
        public bool useMinigunCaliber30mm = false;
        public float minigunCaliber30mmRatio;
        public float minigunCaliber30mmMinValueOfRotation;
        public Transform minigunCaliber30mmBulletInitialPosition;
        public Transform minigunCaliber30mmBarrel;
        float minigunCaliber30mmNextTime;
        float minigunCaliber30mmBarrelSpeed;
        public ParticleSystem minigunCaliber30mmMuzzleFlash;
        public float minigunCaliber30mmBulletSpeed;
        public GameObject minigunCaliber30mmBulletPrefab;
        int Caliber30mmBulletsShot = 0;
        public ParticleSystem Caliber30mmSmokeTrail;
        public GameObject gunEchoPrefab;
        [Header("Countermeasures")]
        public GameObject countermeasurePrefab;
        public Transform countermeasureInitialPositionLeft;
        public Transform countermeasureInitialPositionRight;
        bool countermeasuresFired = false;
        int countermeasureFired = 0;
        int CountermeasuresUntilRecharge = 20;
        public float countermeasureSpeed;
        public float countermeasuresTimer = 0f;

        [Header("Camera")]
        public float Cameradistance = 6.4f;
        public float Cameraheight = 1.4f;
        public float CamerarotationDamping = 3.0f;
        public float CameraheightDamping = 10.0f;
        public float CamerazoomRatio = 0.5f;
        public float CameradefaultFOV = 60f;
        public GameObject FirstPersonCamera;
        public GameObject MinigunCamera;

        [Header("Collision")]
        public GameObject hitEffect;
        public GameObject bloodEffect;
        private float dotP;
        public int demageCount;
        public float currentSpeed = 0;


        private void Start()
        {
            m_Rigidbody = GetComponent<Rigidbody>();
            // Store original drag settings, these are modified during flight.
            m_OriginalDrag = m_Rigidbody.drag;
            m_OriginalAngularDrag = m_Rigidbody.angularDrag;

			/*for (int i = 0; i < transform.childCount; i++ )
			{
				foreach (var componentsInChild in transform.GetChild(i).GetComponentsInChildren<WheelCollider>())
				{
					componentsInChild.motorTorque = 0.18f;
				}
			}*/

            //Select miniguns on start
            rocketsSelected = false;
            minigunsSelectedUI.SetActive(true);
            rocketsSelectedUI.SetActive(false);
        }

        private void Update()
        {
            if (_input == null)
                _input = GameObject.FindGameObjectWithTag("InputManager").GetComponent<StarterAssetsInputs>();
            currentSpeed = transform.GetComponent<Rigidbody>().velocity.magnitude * 3.6f;
            VehicleUI.SetActive(false);
            foreach (VehicleEnterExit.VehicleSync.Seat seat in GetComponent<VehicleEnterExit.VehicleSync>()._seats)
            {
                if (seat.DriverSeat == true)
                {
                    if (seat.Player != null)
                    {
                    }
                    else
                    {
                        for (int i = 0; i < transform.childCount; i++)
                        {
                            foreach (var componentsInChild in transform.GetChild(i).GetComponentsInChildren<WheelCollider>())
                            {
                                componentsInChild.motorTorque = 0;
                            }
                        }
                    }
                }
            }
            if (this.GetComponent<UnityStandardAssets.Vehicles.Aeroplane.AeroplaneUserControl4Axis>() != null)
            {
                if (this.GetComponent<UnityStandardAssets.Vehicles.Aeroplane.AeroplaneUserControl4Axis>().canDrive == false)
                    return;
            }

            if (this.GetComponent<UnityStandardAssets.Vehicles.Aeroplane.AeroplaneUserControl2Axis>() != null)
            {
                if (this.GetComponent<UnityStandardAssets.Vehicles.Aeroplane.AeroplaneUserControl2Axis>().canDrive == false)
                    return;
            }

            VehicleUI.SetActive(true);

            foreach (VehicleEnterExit.VehicleSync.Seat seat in GetComponent<VehicleEnterExit.VehicleSync>()._seats)
            {
                if (seat.DriverSeat == true)
                {
                    if (seat.Player != null)
                    {
                        for (int i = 0; i < transform.childCount; i++)
                        {
                            foreach (var componentsInChild in transform.GetChild(i).GetComponentsInChildren<WheelCollider>())
                            {
                                componentsInChild.motorTorque = 0.18f;
                            }
                        }

                        if (seat.Player.GetComponent<NetPlayer>().username == GetComponent<VehicleEnterExit.VehicleSync>().DriverUsername)
                        {
                            if (seat.Player.GetComponent<ManageTPController>().isFirstPerson == true)
                            {
                                if(!MinigunCamera.activeInHierarchy)
                                    FirstPersonCamera.SetActive(true);
                            }
                            else
                            {
                                FirstPersonCamera.SetActive(false);
                            }
                        }
                    }
                    else
                    {
                        for (int i = 0; i < transform.childCount; i++)
                        {
                            foreach (var componentsInChild in transform.GetChild(i).GetComponentsInChildren<WheelCollider>())
                            {
                                componentsInChild.motorTorque = 0;
                                componentsInChild.brakeTorque = Mathf.Infinity;
                            }
                        }
                    }
                }
            }

            //Change camera mode to minigun camera
            if (_input.sprint & canPlaneShoot & useMinigunCaliber30mm)
            {
                if(MinigunCamera.activeInHierarchy)
                    MinigunCamera.SetActive(false);
                else
                {
                    MinigunCamera.SetActive(true);
                    FirstPersonCamera.SetActive(false);
                }
            }

            //Countermeasures
            if (Input.GetKeyDown(KeyCode.Space))
            {
                if (countermeasuresFired == false)
                {
                    countermeasuresFired = true;
                }
            }

            //Toggle weapons
            if (Input.GetKeyDown(KeyCode.N))
            {
                if(rocketsSelected)
                {
                    minigunAudioSource.Stop();
                    rocketsSelected = false;
                    minigunsSelectedUI.SetActive(true);
                    rocketsSelectedUI.SetActive(false);
                }
                else
                {
                    minigunAudioSource.Stop();
                    rocketsSelected = true;
                    rocketsSelectedUI.SetActive(true);
                    minigunsSelectedUI.SetActive(false);
                }
            }

            if (canPlaneShoot)
            {
                if(_input.shoot)
                {
                    if(rocketsSelected)
                    {
                        if(canShootRocket & shotRockets != 2)
                        {
                            canShootRocket = false;
                            ShootRocket();
                        }
                    }
                    else
                    {
                        if(isOverheating == false)
                        {
                            if(useMinigunCaliber30mm)
                            {
                                minigunCaliber30mmBarrelSpeed = Mathf.Lerp(minigunCaliber30mmBarrelSpeed, 1, 1 * Time.deltaTime);

                                if (Time.time > minigunCaliber30mmNextTime && minigunCaliber30mmBarrelSpeed >= minigunCaliber30mmMinValueOfRotation)
                                {
                                    minigunCaliber30mmNextTime = Time.time + minigunCaliber30mmRatio;
                                    if (minigunAudioSource.isPlaying == false)
                                    {
                                        minigunAudioSource.clip = minigunSound;
                                        minigunAudioSource.Play();
                                    }
                                    Caliber30mmBulletsShot += 1;
                                    ClientShootCaliber30mmBullet();
                                }
                                minigunCaliber30mmBarrel.Rotate(Vector3.forward * minigunCaliber30mmBarrelSpeed * 360);
                            }
                            else
                            {
                                ClientShootBulletBoth();
                                if (minigunAudioSource.isPlaying == false)
                                {
                                    minigunAudioSource.clip = minigunSound;
                                    minigunAudioSource.Play();
                                }
                            }
                        }
                        else
                        {
                            minigunAudioSource.Stop();
                            if (useMinigunCaliber30mm)
                            {
                                minigunCaliber30mmBarrelSpeed = Mathf.Lerp(minigunCaliber30mmBarrelSpeed, 0, 1 * Time.deltaTime);
                                if (Caliber30mmSmokeTrail.isPlaying)
                                    CmdStopCaliber30mmSmokeTrail();
                                minigunCaliber30mmBarrel.Rotate(Vector3.forward * minigunCaliber30mmBarrelSpeed * 360);
                                if (Caliber30mmBulletsShot > 0)
                                {
                                    CmdSpawnCaliber30mmBulletShotEchoSound(Caliber30mmBulletsShot, transform.position, transform.rotation);
                                    Caliber30mmBulletsShot = 0;
                                }
                            }
                        }
                    }
                }
                else
                {
                    minigunAudioSource.Stop();
                    if (useMinigunCaliber30mm)
                    {
                        minigunCaliber30mmBarrelSpeed = Mathf.Lerp(minigunCaliber30mmBarrelSpeed, 0, 1 * Time.deltaTime);
                        if (Caliber30mmSmokeTrail.isPlaying)
                            CmdStopCaliber30mmSmokeTrail();
                        minigunCaliber30mmBarrel.Rotate(Vector3.forward * minigunCaliber30mmBarrelSpeed * 360);
                        if(Caliber30mmBulletsShot > 0)
                        {
                            CmdSpawnCaliber30mmBulletShotEchoSound(Caliber30mmBulletsShot, transform.position, transform.rotation);
                            Caliber30mmBulletsShot = 0;
                        }
                    }
                }
            }

            if(countermeasuresFired == true)
            {
                countermeasuresTimer += Time.deltaTime;
                if (countermeasuresTimer >= 1f)
                {
                    countermeasuresTimer = countermeasuresTimer % 1f;

                    ShootCountermeasure();
                }
            }

            if (isServer)
            {
                RpcSyncThrottle(Throttle);
            }
            else if (hasAuthority)
            {
                CmdSyncThrottle(Throttle);
            }
        }

        public void Move(float rollInput, float pitchInput, float yawInput, float throttleInput, bool airBrakes)
        {
            // transfer input parameters into properties.s
            RollInput = rollInput;
            PitchInput = pitchInput;
            YawInput = yawInput;
            ThrottleInput = throttleInput;
            AirBrakes = airBrakes;

            ClampInputs();

            CalculateRollAndPitchAngles();

            AutoLevel();

            CalculateForwardSpeed();

            ControlThrottle();

            CalculateDrag();

            CaluclateAerodynamicEffect();

            CalculateLinearForces();

            CalculateTorque();

            CalculateAltitude();
        }

        //TODO: network
        public void ShootRocket()
        {
            if (!rocketShot & currentRocketInitialPosition == "Left")
            {
                rocketShot = true;
                ShootRocket(1, rocketInitialPositionLeft.position, rocketInitialPositionLeft.rotation);

                currentRocketInitialPosition = "Right";


                shotRockets += 1;
                availableRockets -= 1;

                if (shotRockets >= 2)
                {
                    StartCoroutine(RacketsCharging());
                }
                else
                {
                    if (hasDelay)
                        StartCoroutine(Delay());
                    else
                    {
                        rocketShot = false;
                        canShootRocket = true;
                    }
                }

            }
            else if (!rocketShot & currentRocketInitialPosition == "Right")
            {

                ShootRocket(0, rocketInitialPositionRight.position, rocketInitialPositionRight.rotation);

                currentRocketInitialPosition = "Left";


                shotRockets += 1;
                availableRockets -= 1;

                if (shotRockets >= 2)
                {
                    StartCoroutine(RacketsCharging());
                }
                else
                {
                    if (hasDelay)
                        StartCoroutine(Delay());
                    else
                    {
                        rocketShot = false;
                        canShootRocket = true;
                    }
                }
            }
        }

        [Command]
        void ShootRocket(int side, Vector3 _position, Quaternion _rotation)
        {
            //side: 0 for right, 1 for left
     /*       print("Shoot: " + side);
            currentRocketInitialPosition = (side == 0 ? "Left": "Right");


            shotRockets += 1;
            availableRockets -= 1;*/

            GameObject Rocket = Instantiate(rocketPrefab, _position, _rotation) as GameObject;
            NetworkServer.Spawn(Rocket, connectionToClient);

            RpcRocketShoot(side, Rocket.GetComponent<Projectile>(), shotRockets, availableRockets);
        }

        [ClientRpc]
        void RpcRocketShoot(int side, Projectile rocket, int _shotRockets, int _availableRockets) 
        {
          /*  if (!isServer)
            {
                shotRockets = _shotRockets;
                availableRockets = _availableRockets;
            }*/

            shotRocketsText.text = availableRockets.ToString();

            if (side == 0)
                rocketObjectRight.SetActive(false);
            else
                rocketObjectLeft.SetActive(false);

            rocket.GetComponent<NetworkRocket>().SetupProjectile(currentPlayerUsername(), hasAuthority);
            rocket.SetupProjectile_ServerSide();

            rocket.GetComponent<Rigidbody>().AddForce(rocket.transform.forward * rocketSpeed);

            /*    if (side == 1)
                {
                    if (hasDelay)
                        StartCoroutine(Delay());
                    else
                        rocketShot = false;
                }
                else
                {
                    if (shotRockets == 2)
                        StartCoroutine(RacketsCharging());
                }*/
            
        }

        /* void ShootLeftRocket(int side, Vector3 _position, Quaternion _rotation, float _rocketSpeed, string shooterUsername)
         {
             //side: 0 for right, 1 for left

             currentRocketInitialPosition = "Right";
             shotRockets += 1;
             availableRockets -= 1;
             shotRocketsText.text = availableRockets.ToString();
             rocketObjectLeft.SetActive(false);

             GameObject Rocket = Instantiate(rocketPrefab, _position, _rotation) as GameObject;
             NetworkServer.Spawn(Rocket, connectionToClient);

             Rocket.GetComponent<NetworkRocket>().SetupProjectile(shooterUsername, hasAuthority);

             Rocket.GetComponent<Rigidbody>().AddForce(Rocket.transform.forward * _rocketSpeed);

             if (hasDelay)
                 StartCoroutine(Delay());
             else
                 rocketShot = false;
         }*/

        /*  void ShootRightRocket(int side, Vector3 _position, Quaternion _rotation, float _rocketSpeed, string shooterUsername)
          {
              currentRocketInitialPosition = "Left";
              shotRockets += 1;
              availableRockets -= 1;
              shotRocketsText.text = availableRockets.ToString();
              rocketObjectRight.SetActive(false);
              GameObject Rocket = Instantiate(rocketPrefab, _position, _rotation) as GameObject;
              NetworkServer.Spawn(Rocket, connectionToClient);

              Rocket.GetComponent<Rigidbody>().AddForce(Rocket.transform.forward * _rocketSpeed);

              if (shotRockets == 2)
                  StartCoroutine(RacketsCharging());
          }*/

        public void ClientShootCaliber30mmBullet()
        {
            ShootCaliber30mmBullet(minigunCaliber30mmBulletInitialPosition.position, minigunCaliber30mmBulletInitialPosition.rotation);
        }

        [Command]
        void ShootCaliber30mmBullet(Vector3 _position, Quaternion _rotation)
        {
            bulletsShot += 1;
            minigunCaliber30mmMuzzleFlash.Play();
            Caliber30mmSmokeTrail.Play();
            GameObject Caliber30mmBullet = Instantiate(minigunCaliber30mmBulletPrefab, _position, _rotation) as GameObject;
            NetworkServer.Spawn(Caliber30mmBullet, connectionToClient);

            RpcShootCaliber30mmBullet(Caliber30mmBullet.GetComponent<Projectile>(), bulletsShot);
        }

        [ClientRpc]
        void RpcShootCaliber30mmBullet(Projectile Caliber30mmBullet, int bulletsShoot)
        {
            bulletsShot = bulletsShoot;
            minigunCaliber30mmMuzzleFlash.Play();
            Caliber30mmSmokeTrail.Play();
            Caliber30mmBullet.GetComponent<NetworkRocket>().SetupProjectile(currentPlayerUsername(), hasAuthority);
            Caliber30mmBullet.SetupProjectile_ServerSide();

            Caliber30mmBullet.GetComponent<Rigidbody>().AddForce(Caliber30mmBullet.transform.forward * minigunCaliber30mmBulletSpeed);

            if (bulletsShot > ShotsUntilOverheating)
            {
                isOverheating = true;
                overheatingUI.SetActive(true);
                /*minigunAudioSource.clip = overheatingSound;
                minigunAudioSource.Play();*/
                StartCoroutine(OverheatingCoolDownCoroutine());
            }
        }

        [Command]
        void CmdStopCaliber30mmSmokeTrail()
        {
            Caliber30mmSmokeTrail.Stop();

            RpcStopCaliber30mmSmokeTrail();
        }

        [ClientRpc]
        void RpcStopCaliber30mmSmokeTrail()
        {
            Caliber30mmSmokeTrail.Stop();
        }

        private IEnumerator Delay()
        {
            yield return new WaitForSeconds(rocketsDelay);

            rocketShot = false;
            canShootRocket = true;
        }

        private IEnumerator RacketsCharging()
        {
            yield return new WaitForSeconds(3);

            rocketObjectLeft.SetActive(true);
            rocketObjectRight.SetActive(true);
            shotRockets = 0;
            availableRockets = 2;
            shotRocketsText.text = availableRockets.ToString();
            canShootRocket = true;
        }


        void ClientShootBulletBoth()
        {
            ShootBulletBoth();
        }

        [Command]
        public void ShootBulletBoth()
        {
            ShootBullet(bulletInitialPositionLeft.position, bulletInitialPositionLeft.rotation, bulletSpeed, currentPlayerUsername());

            ShootBullet(bulletInitialPositionRight.position, bulletInitialPositionRight.rotation, bulletSpeed, currentPlayerUsername());
        }

        void ShootBullet(Vector3 _position, Quaternion _rotation, float _bulletSpeed, string shooterUsername)
        {
            bulletsShot += 1;
            GameObject Bullet = Instantiate(bulletPrefab, _position, _rotation) as GameObject;
            NetworkServer.Spawn(Bullet);

            NetworkBullet bullet = Bullet.GetComponent<NetworkBullet>();
            bullet.netIdentity.AssignClientAuthority(this.connectionToClient);

            bullet.SetupProjectile_ServerSide();

            RpcBulletFired(bullet, bulletsShot);

        }
        [ClientRpc]
        void RpcBulletFired(NetworkBullet Bullet, int bulletsShoot) 
        {
            bulletsShot = bulletsShoot;

            Bullet.GetComponent<NetworkBullet>().SetupProjectile(currentPlayerUsername(), hasAuthority);

            Bullet.GetComponent<Rigidbody>().AddForce(Bullet.transform.forward * bulletSpeed);

            if (bulletsShot > ShotsUntilOverheating)
            {
                isOverheating = true;
                overheatingUI.SetActive(true);
                /*minigunAudioSource.clip = overheatingSound;
                minigunAudioSource.Play();*/
                StartCoroutine(OverheatingCoolDownCoroutine());
            }
        }

        private IEnumerator OverheatingCoolDownCoroutine()
        {
            yield return new WaitForSeconds(OverheatingCoolDown);

            bulletsShot = 0;
            overheatingUI.SetActive(false);
            isOverheating = false;

            CmdCoolDownOverheating();
        }

        [Command]
        void CmdCoolDownOverheating()
        {
            bulletsShot = 0;
            isOverheating = false;

            RpcCoolDownOverheating();
        }

        [ClientRpc]
        void RpcCoolDownOverheating()
        {
            bulletsShot = 0;
            isOverheating = false;
        }

        [Command]
        void CmdSyncThrottle(float _throttle)
        {
            Throttle = _throttle;

            RpcSyncThrottle(_throttle);
        }

        [ClientRpc]
        void RpcSyncThrottle(float _throttle)
        {
            Throttle = _throttle;
        }

        //TODO: network
        public void ShootCountermeasure()
        {
            ShootCountermeasure(countermeasureInitialPositionLeft.position, countermeasureInitialPositionLeft.rotation, countermeasureSpeed);
            ShootCountermeasure(countermeasureInitialPositionRight.position, countermeasureInitialPositionRight.rotation, countermeasureSpeed);
        }

        void ShootCountermeasure(Vector3 _position, Quaternion _rotation, float _countermeasureSpeed)
        {
            countermeasureFired += 1;
            GameObject Countermeasure = Instantiate(countermeasurePrefab, _position, _rotation) as GameObject;

            Countermeasure.GetComponent<Rigidbody>().AddForce(Countermeasure.transform.forward * _countermeasureSpeed);

            Destroy(Countermeasure, 20);

            if (countermeasureFired >= CountermeasuresUntilRecharge)
            {
                countermeasureFired = 0;
                countermeasuresFired = false;
                countermeasuresTimer = 0;
            }
        }

        void OnCollisionEnter(Collision collision)
        {
            if (collision.gameObject.tag != "Player" & collision.gameObject.layer != 6)
            {
                GameObject hit = collision.gameObject;

                ContactPoint contact = collision.contacts[0];
                Quaternion rot = Quaternion.FromToRotation(Vector3.up, contact.normal);
                Vector3 pos = contact.point;
                SpawnHitEffect(pos, rot);
                demageCount = (int)currentSpeed;

                if (collision.gameObject.tag != "Bullet")
                {
                    if (isServer)
                    {
                        RpcSetCrashDemage(demageCount);
                    }
                    else if (hasAuthority)
                    {
                        CmdSetCrashDemage(demageCount);
                    }
                }
            }
            if (collision.gameObject.tag == "Player" & collision.gameObject.layer == 6)
            {
                GameObject hit = collision.gameObject;

                ContactPoint contact = collision.contacts[0];
                Quaternion rot = Quaternion.FromToRotation(Vector3.up, contact.normal);
                Vector3 pos = contact.point;
                demageCount = (int)currentSpeed;
                if(demageCount > 10)
                {
                    SpawnBloodEffect(pos, rot);

                    if (isServer)
                    {
                        RpcSetPlayerDemage(100, collision.gameObject.GetComponent<Health>());

                        //RpcSetCrashDemage(5);
                    }
                    else if (hasAuthority)
                    {
                        CmdSetPlayerDemage(100, collision.gameObject.GetComponent<Health>());

                        //CmdSetCrashDemage(5);
                    }
                }
            }
        }

        [Command]
        void CmdSetCrashDemage(int _demage)
        {
            GetComponent<VehicleHealth>().TakeDamage(_demage);
        }

        [ClientRpc]
        void RpcSetCrashDemage(int _demage)
        {
            GetComponent<VehicleHealth>().TakeDamage(_demage);
        }

        void SpawnHitEffect(Vector3 _position, Quaternion _rotation)
        {
            Instantiate(hitEffect, _position, _rotation);
        }

        [Command]
        void CmdSetPlayerDemage(int _demage, Health _health)
        {
            _health.TakeDamage(_demage, AttackType.Plane, currentPlayerUsername());
        }

        [ClientRpc]
        void RpcSetPlayerDemage(int _demage, Health _health)
        {
            _health.TakeDamage(_demage, AttackType.Plane, currentPlayerUsername());
        }

        void SpawnBloodEffect(Vector3 _position, Quaternion _rotation)
        {
            Instantiate(bloodEffect, _position, _rotation);
        }

        [Command]
        void CmdSpawnCaliber30mmBulletShotEchoSound(int shotCaliber30mmBullets, Vector3 _position, Quaternion _rotation)
        {
            GameObject Caliber30mmBulletShotEchoSound = Instantiate(gunEchoPrefab, _position, _rotation) as GameObject;

            NetworkServer.Spawn(Caliber30mmBulletShotEchoSound, connectionToClient);

            GunEcho caliber30mmBulletShotEchoSound = Caliber30mmBulletShotEchoSound.GetComponent<GunEcho>();
            caliber30mmBulletShotEchoSound.netIdentity.AssignClientAuthority(this.connectionToClient);

            RpcSpawnCaliber30mmBulletShotEchoSound(caliber30mmBulletShotEchoSound, shotCaliber30mmBullets);
        }

        [ClientRpc]
        void RpcSpawnCaliber30mmBulletShotEchoSound(GunEcho caliber30mmBulletShotEchoSound, int shotCaliber30mmBullets)
        {
            caliber30mmBulletShotEchoSound.GetComponent<GunEcho>().StartEcho(shotCaliber30mmBullets, currentPlayerUsername());
        }

        private void ClampInputs()
        {
            // clamp the inputs to -1 to 1 range
            RollInput = Mathf.Clamp(RollInput, -1, 1);
            PitchInput = Mathf.Clamp(PitchInput, -1, 1);
            YawInput = Mathf.Clamp(YawInput, -1, 1);
            ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
        }


        private void CalculateRollAndPitchAngles()
        {
            // Calculate roll & pitch angles
            // Calculate the flat forward direction (with no y component).
            var flatForward = transform.forward;
            flatForward.y = 0;
            // If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
            if (flatForward.sqrMagnitude > 0)
            {
                flatForward.Normalize();
                // calculate current pitch angle
                var localFlatForward = transform.InverseTransformDirection(flatForward);
                PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.z);
                // calculate current roll angle
                var flatRight = Vector3.Cross(Vector3.up, flatForward);
                var localFlatRight = transform.InverseTransformDirection(flatRight);
                RollAngle = Mathf.Atan2(localFlatRight.y, localFlatRight.x);
            }
        }


        private void AutoLevel()
        {
            // The banked turn amount (between -1 and 1) is the sine of the roll angle.
            // this is an amount applied to elevator input if the user is only using the banking controls,
            // because that's what people expect to happen in games!
            m_BankedTurnAmount = Mathf.Sin(RollAngle);
            // auto level roll, if there's no roll input:
            if (RollInput == 0f)
            {
                RollInput = -RollAngle*m_AutoRollLevel;
            }
            // auto correct pitch, if no pitch input (but also apply the banked turn amount)
            if (PitchInput == 0f)
            {
                PitchInput = -PitchAngle*m_AutoPitchLevel;
                PitchInput -= Mathf.Abs(m_BankedTurnAmount*m_BankedTurnAmount*m_AutoTurnPitch);
            }
        }


        private void CalculateForwardSpeed()
        {
            // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
            var localVelocity = transform.InverseTransformDirection(m_Rigidbody.velocity);
            ForwardSpeed = Mathf.Max(0, localVelocity.z);
        }


        private void ControlThrottle()
        {
            // override throttle if immobilized
            if (m_Immobilized)
            {
                ThrottleInput = -0.5f;
            }

            // Adjust throttle based on throttle input (or immobilized state)
            Throttle = Mathf.Clamp01(Throttle + ThrottleInput*Time.deltaTime*m_ThrottleChangeSpeed);

            // current engine power is just:
            EnginePower = Throttle*m_MaxEnginePower;
        }


        private void CalculateDrag()
        {
            // increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
            float extraDrag = m_Rigidbody.velocity.magnitude*m_DragIncreaseFactor;
            // Air brakes work by directly modifying drag. This part is actually pretty realistic!
            m_Rigidbody.drag = (AirBrakes ? (m_OriginalDrag + extraDrag)*m_AirBrakesEffect : m_OriginalDrag + extraDrag);
            // Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
            m_Rigidbody.angularDrag = m_OriginalAngularDrag*ForwardSpeed;
        }


        private void CaluclateAerodynamicEffect()
        {
            // "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
            // will naturally try to align itself in the direction that it's facing when moving at speed.
            // Without this, the plane would behave a bit like the asteroids spaceship!
            if (m_Rigidbody.velocity.magnitude > 0)
            {
                // compare the direction we're pointing with the direction we're moving:
                m_AeroFactor = Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized);
                // multipled by itself results in a desirable rolloff curve of the effect
                m_AeroFactor *= m_AeroFactor;
                // Finally we calculate a new velocity by bending the current velocity direction towards
                // the the direction the plane is facing, by an amount based on this aeroFactor
                var newVelocity = Vector3.Lerp(m_Rigidbody.velocity, transform.forward*ForwardSpeed,
                                               m_AeroFactor*ForwardSpeed*m_AerodynamicEffect*Time.deltaTime);
                m_Rigidbody.velocity = newVelocity;

                // also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
                // pointing downwards in a stall
                m_Rigidbody.rotation = Quaternion.Slerp(m_Rigidbody.rotation,
                                                      Quaternion.LookRotation(m_Rigidbody.velocity, transform.up),
                                                      m_AerodynamicEffect*Time.deltaTime);
            }
        }


        private void CalculateLinearForces()
        {
            // Now calculate forces acting on the aeroplane:
            // we accumulate forces into this variable:
            var forces = Vector3.zero;
            // Add the engine power in the forward direction
            forces += EnginePower*transform.forward;
            // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
            var liftDirection = Vector3.Cross(m_Rigidbody.velocity, transform.right).normalized;
            // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
            // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
            // a simple way of doing it automatically:
            var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed);
            // Calculate and add the lift power
            var liftPower = ForwardSpeed*ForwardSpeed*m_Lift*zeroLiftFactor*m_AeroFactor;
            forces += liftPower*liftDirection;
            // Apply the calculated forces to the the Rigidbody
            m_Rigidbody.AddForce(forces);
        }


        private void CalculateTorque()
        {
            // We accumulate torque forces into this variable:
            var torque = Vector3.zero;
            // Add torque for the pitch based on the pitch input.
            torque += PitchInput*m_PitchEffect*transform.right;
            // Add torque for the yaw based on the yaw input.
            torque += YawInput*m_YawEffect*transform.up;
            // Add torque for the roll based on the roll input.
            torque += -RollInput*m_RollEffect*transform.forward;
            // Add torque for banked turning.
            torque += m_BankedTurnAmount*m_BankedTurnEffect*transform.up;
            // The total torque is multiplied by the forward speed, so the controls have more effect at high speed,
            // and little effect at low speed, or when not moving in the direction of the nose of the plane
            // (i.e. falling while stalled)
            m_Rigidbody.AddTorque(torque*ForwardSpeed*m_AeroFactor);
        }


        private void CalculateAltitude()
        {
            // Altitude calculations - we raycast downwards from the aeroplane
            // starting a safe distance below the plane to avoid colliding with any of the plane's own colliders
            var ray = new Ray(transform.position - Vector3.up*10, -Vector3.up);
            RaycastHit hit;
            Altitude = Physics.Raycast(ray, out hit) ? hit.distance + 10 : transform.position.y;
        }


        // Immobilize can be called from other objects, for example if this plane is hit by a weapon and should become uncontrollable
        public void Immobilize()
        {
            m_Immobilized = true;
        }


        // Reset is called via the ObjectResetter script, if present.
        public void Reset()
        {
            m_Immobilized = false;
        }

        public string currentPlayerUsername()
        {
            return GetComponent<VehicleSync>().DriverUsername;
        }
    }
}
